<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>Making a Chord Graph</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
  #map_1,#map_2,#map_3 {
    height: 500px;
  }
  </style>

  <!-- D3 v3 -->
  <script src="https://d3js.org/d3.v3.min.js"></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Mobility on Demand Systems: Data-Driven Analysis, Simulation, Visualization</h2>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    </div>
    <div class="two columns">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="twelve columns">
      <h3>Making a Chord Graph</h3>
      <p>
        In this tutorial, you will learn how to make a chord graph.
        This example uses <a href="https://d3js.org/d3.v3.min.js">D3.js v3</a> and <a href="http://getskeleton.com/">Skeleton</a> boilerplate.
      </p>
    </div>
  </div>


  <div class="container" >
    <div id="chord_01" class="twelve columns">
    </div>
  </div>

  <div class="container half-bottom">
    <div class="twelve columns">
      <h3>Step 1: Setup</h3>
      <p>First, you declare and initiate your control variables, such as number of trips, number of stations, margin and width of the SVG HTML element that will contain the graph, and thickness, diameter, and color for your chord graph's arcs and chords</p>
      <pre>
        <code>
          // STEP 1: Setup
          var nTrips = 30;
          var nStations = 6;

          var margin = 0;
          var width = 600;

          var xPos = margin;
          var yPos = margin;

          var thickness = 30;
          var diameter = width - 2*margin;
          var outerRadius = diameter / 2;
          var innerRadius = outerRadius - thickness;

          var color = d3.scale.linear()
            .domain([0, nStations])
            .range([d3.rgb(255,0,0), d3.rgb(50,0,0)]);
        </code>
      </pre>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>STEP 2: Create/Get Data and OD Matrix</h3>
      <p>Next, you need trip data and station data. You can get real data from anywhere you want. In this tutorial, we create trip and station data synthetically, through functions.
        After you get or create the trip and station data you will need to organize them into an OD (origin-destination) matrix. We thus create a third function <code>createMatrix()</code> to create the OD matrix.</p>
      <pre>
        <code>
          // STEP 2: Create/Get Data and OD Matrix
          var tripData = createTripData(nTrips, nStations);
          var stationData = createStationData(nStations);
          var od_matrix = createMatrix(tripData, stationData);
        </code>
      </pre>

      <p>The function to create trip data takes as input arguments the number of trips <code>nTrips</code> and the number of stations <code>nStations</code>:</p>
      <pre>
        <code>
          function createTripData(nTrips, nStations){
            var trips = [];
            for(var i=0; i< nTrips; i++){
              var origin_index = Math.floor(Math.random() * nStations);
              var destination_index = Math.floor(Math.random() * nStations);
              trips.push({
                start_station: origin_index,
                end_station: destination_index
              })
            }
            return trips;
          }
        </code>
      </pre>

      <p>The function to create station data takes as input arguments the number of stations <code>nStations</code>:</p>
      <pre>
        <code>
          function createStationData(nStations){
            var stations=[];
            for(var i=0; i< nStations; i++){
              stations.push({
                name: i
              })
            }
            return stations;
          }
        </code>
      </pre>

      <p>The function to create an OD matrix from <code>tripData</code> and <code>stationData</code> is:</p>
      <pre>
        <code>
          function createMatrix(tripData, stationData){
            var indexByNameTrip = d3.map();
            var nameByIndexTrip = d3.map();
            var n = 0;
            tripData.forEach(function(d) {
              if (!indexByNameTrip.has(d.start_station)) {
                nameByIndexTrip.set(n, d.start_station);
                indexByNameTrip.set(d.start_station, n++);
              }

            });

            var indexByNameStation = d3.map();
            var nameByIndexStation = d3.map();
            var j = 0;
            stationData.forEach(function(d) {
              if (!indexByNameStation.has(d.name)) {
                nameByIndexStation.set(j, d.name);
                indexByNameStation.set(d.name, j++);
              }
            });


            //Create the OD matrix
            var od_matrix = [];
            tripData.forEach(function(d) {
              var  startStationIndex = indexByNameTrip.get(d.start_station);
              var  endStationIndex = indexByNameTrip.get(d.end_station);
              if (!od_matrix[startStationIndex]) {
                od_matrix[startStationIndex] = [];
                for (var i = 0; i < n; i++) {
                  od_matrix[startStationIndex][i] = 0;
                }
              }
              od_matrix[startStationIndex][endStationIndex]++;;
            });
            return od_matrix;
          }
        </code>
      </pre>
    </div>
  </div>

  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 3: Create Chord Layout</h3>
      <p>
        <code>d3.layout.chord()</code> is a D3 layout object. Read about D3 Layouts <a href="https://d3indepth.com/layouts/">here</a> and about Chord Layout <a href="https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/">here</a>.
        <br>
        Once the Chord Layout is being passed an OD matrix <code>d3.layout.chord().matrix(od_matrix)</code>, it then returns groups and chords arrays as follows:
        <br>
        function <code>d3.layout.chord().groups()</code> returns the groups
        <br>
        function <code>d3.layout.chord().chords()</code> returns the chords
      </p>
      <pre>
        <code>
          // STEP 3: Create Chord Layout
          var chordLayout = d3.layout.chord()
          .matrix(od_matrix)
          .padding(0.05)
          .sortGroups(d3.descending);
        </code>
      </pre>
      <p>Instead of <code>d3.descending</code>, you can also pass custom sorting functions that compare two objects such as <code>function(a,b){...}</code> </p>
    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 4: Create SVG Shape Generators for arcs and chords</h3>
      <p>
        SVG Shape Generators are special objects in D3 that are used to generate the necessary code for automatically creating SVG elements.
        Since chord graphs consist of arcs and chords, to create a chord graph, we need SVG shape generators to create arcs and chords.
        Read more about SVG Shape Generators <a href="https://d3indepth.com/shapes/">here</a>.
      </p>
      <p>
        <code>d3.svg.arc()</code> is an SVG Shape Generator that is used to create arcs.
        <code>d3.svg.arc()</code> takes a group object as an input and returns its path
        To define an arc SVG Shape Generator you first need to define the inner and outer radii
        function chordLayout.groups() returns an array with all groups (e.g. arc sectors)
        each group object contains a start angle, an end angle, an index number, and a value.
        for example, arc(chordLayout.groups()[2]) returns the path of the third group
      </p>
      <pre>
        <code>
          var arc = d3.svg.arc()
              .innerRadius(innerRadius)
              .outerRadius(outerRadius);
        </code>
      </pre>
      <p>
        Likewise, <code>d3.svg.chord()</code> is an SVG Shape Generator to create chords. It takes a chord object as an input and returns its path.
        To define a chord SVG Shape Generator you first need to define the radious:
      </p>
      <pre>
        <code>
          var chord = d3.svg.chord()
            .radius(innerRadius - 5);
        </code>
      </pre>
      <p>
        <code>chordLayout.chords()</code> returns an array with all chords.
        Each chord object consists of a source and a target, and each of the source and target is a segment of a group with its own start angle and end angle.
        For example, <code>chord(chordLayout.chords()[12])</code> returns the path of the 13th chord.
      </p>
    </div>
  </div>



  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 5: Create the SVG and an empty group "g" to contain the Arc and Chord Shapes that you will be generating</h3>
      <p>
        Create an SVG element in the body of the html page, and define its width and height.
        Then, append an empty "group" (<code>g</code>) inside it, and determine its X,Y origin. The group <code>g</code> is empty because we haven't created anything inside it yet.
        You need this <code>g</code> element in order to start embedding paths inside it and still consider them as one single object (instead of multiple independent paths).
      </p>
      <pre>
        <code>
          var svgGroup = d3.select("#chord_01").append("svg")
            .attr("width", 800)
            .attr("height", 800)
            .append("g")
            .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
        </code>
      </pre>
    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 6: Draw Arcs/Groups</h3>
      <p>

      </p>
      <pre>
        <code>
          svgGroup.selectAll(".group")
            .data(chordLayout.groups())
            .enter()
            .append("g")
            .attr("class", "group")
            .append("path")
            .attr("id", function(d, i) { return "group" + i; })
            .style("fill", function(d) { return color(d.index); })
            .style("stroke", d3.rgb(0,0,0))
            .style("stroke-width", 1)
            .attr("d", function(d) { return arc(d)});
        </code>
      </pre>
    </div>
  </div>

  <div class="container" >
    <div id="chord_02" class="twelve columns">
    </div>
  </div>



  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 7: Draw Chords</h3>
      <p>

      </p>
      <pre>
        <code>
          svgGroup.selectAll(".chord")
            .data(chordLayout.chords())
            .enter()
            .append("path")
            .attr("class", "chord")
            .style("fill", d3.rgb(180,180,180))
            .style("stroke", d3.rgb(180,180,180).darker(3))
            .style("opacity", 0.5)
            .attr("d", function(d) { return chord(d)} );
        </code>
      </pre>
    </div>
  </div>


  <div class="container" >
    <div id="chord_03" class="twelve columns">
    </div>
  </div>


  <div class="container one-bottom" style="margin-top: 50px">
    <div class="four columns offset-by-four">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>


  <script type="text/javascript">

    // Chord Graph Tutorial by Dimitris Papanikolaou
    // 2019 02 3


    // STEP 1: Setup
    var nTrips = 30;
    var nStations = 6;

    var margin = 0;
    var width = 600;

    var xPos = margin;
    var yPos = margin;

    var thickness = 30;
    var diameter = width - 2*margin;
    var outerRadius = diameter / 2;
    var innerRadius = outerRadius - thickness;

    var color = d3.scale.linear()
      .domain([0, nStations])
      .range([d3.rgb(255,0,0), d3.rgb(50,0,0)]);


    // STEP 2: Create/Get Data and OD Matrix
    var tripData = createTripData(nTrips, nStations);
    var stationData = createStationData(nStations);
    var od_matrix = createMatrix(tripData, stationData);



    // STEP 3: Create Chord Layout
    var chordLayout = d3.layout.chord()
      .matrix(od_matrix)
      .padding(0.05)
      .sortGroups(d3.descending); // You can also pass custom sorting functions that compare two objects like function(a,b){...}
    // About d3.layout.chord():
    // d3.layout.chord() is a D3 layout object. Read about D3 Layouts here: https://d3indepth.com/layouts/ and about Chord Layout here: https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/
    // Once the Chord Layout is being assigned an OD matrix ( d3.layout.chord().matrix(od_matrix) ), it can return groups and chords arrays as follows:
    // function chordLayout.groups() returns the groups
    // function chordLayout.chords() returns the chords


    // STEP 4: Create SVG Shape Generators for arcs and chords
    var arc = d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);
    // About d3.svg.arc():
    // d3.svg.arc() is an SVG Shape Generator. Read more about SVG Shape Generators here: https://d3indepth.com/shapes/
    // d3.svg.arc() takes a group object as an input and returns its path
    // To define an arc SVG Shape Generator you first need to define the inner and outer radii
    // function chordLayout.groups() returns an array with all groups (e.g. arc sectors)
    // each group object contains a start angle, an end angle, an index number, and a value.
    // for example, arc(chordLayout.groups()[2]) returns the path of the third group


    var chord = d3.svg.chord()
      .radius(innerRadius - 5);
    // About d3.svg.chord():
    // d3.svg.chord() is also an SVG Shape Generator. It takes a chord object as an input and returns its path
    // To define a chord SVG Shape Generator you first need to define the radious
    // chordLayout.chords() returns an array with all chords
    // each chord object consists of a source and a target, and each of the source and target is a segment of a group with its own start angle and end angle
    // for example, chord(chordLayout.chords()[12]) returns the path of the 13th chord


    // STEP 5: Create the SVG and an empty group "g" to contain the Arc and Chord Shapes that you will be generating
    var svgGroup = d3.select("#chord_01").append("svg")
      .attr("width", 800)
      .attr("height", 800)
      .append("g")
      .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
    // Create an SVG element in the body of the html page, and define its width and height
    // Then, append an empty "group" (g) inside it, and determine its X,Y origin
    // You need this g element in order to start embedding paths inside it and consider them as a single object.



    // STEP 6: Draw Arcs/Groups
    svgGroup.selectAll(".group")
      .data(chordLayout.groups())
      .enter()
      .append("g")
      .attr("class", "group")
      .append("path")
      .attr("id", function(d, i) { return "group" + i; })
      .style("fill", function(d) { return color(d.index); })
      .style("stroke", d3.rgb(0,0,0))
      .style("stroke-width", 1)
      .attr("d", function(d) { return arc(d)})
      .on("hover", function (d,i) {
      })
      .on("click", function (d,i) {
      });

    // STEP 7: Draw Chords
    svgGroup.selectAll(".chord")
      .data(chordLayout.chords())
      .enter()
      .append("path")
      .attr("class", "chord")
      .style("fill", d3.rgb(180,180,180))
      .style("stroke", d3.rgb(180,180,180).darker(3))
      .style("opacity", 0.5)
      // .style("opacity", function(d){
      // 	if(d.source.index==2 || d.target.index==2)
      // 		return 1;
      // 	else
      // 		return 0.1
      // })
      .attr("d", function(d) { return chord(d)} )
      .on("hover", function (d) {
      })
      .on("click", function (d,i) {
      });




      var svg2 = d3.select("#chord_02").append("svg")
        .attr("width", 800)
        .attr("height", 800)
        .append("g")
        .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
      svg2.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});


      var svg3 = d3.select("#chord_03").append("svg")
        .attr("width", 800)
        .attr("height", 800)
        .append("g")
        .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
      svg3.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});
      svg3.selectAll(".chord")
        .data(chordLayout.chords())
        .enter()
        .append("path")
        .attr("class", "chord")
        .style("fill", d3.rgb(180,180,180))
        .style("stroke", d3.rgb(180,180,180).darker(3))
        .style("opacity", 0.5)
        .attr("d", function(d) { return chord(d)} );



    /********************/
    /********************/
    /***** FUNCTIONS ****/
    /********************/
    /********************/


    function createTripData(nTrips, nStations){
      var trips = [];
      for(var i=0; i<nTrips; i++){
        var origin_index = Math.floor(Math.random() * nStations);
        var destination_index = Math.floor(Math.random() * nStations);
        trips.push({
          start_station: origin_index,
          end_station: destination_index
        })
      }
      return trips;
    }
    function createStationData(nStations){
      var stations=[];
      for(var i=0; i<nStations; i++){
        stations.push({
          name: i
        })
      }
      return stations;
    }

    function createMatrix(tripData, stationData){
      var indexByNameTrip = d3.map();
      var nameByIndexTrip = d3.map();
      var n = 0;
      tripData.forEach(function(d) {
        if (!indexByNameTrip.has(d.start_station)) {
          nameByIndexTrip.set(n, d.start_station);
          indexByNameTrip.set(d.start_station, n++);
        }

      });

      var indexByNameStation = d3.map();
      var nameByIndexStation = d3.map();
      var j = 0;
      stationData.forEach(function(d) {
        if (!indexByNameStation.has(d.name)) {
          nameByIndexStation.set(j, d.name);
          indexByNameStation.set(d.name, j++);
        }
      });


      //Create the OD matrix
      var od_matrix = [];
      tripData.forEach(function(d) {
        var  startStationIndex = indexByNameTrip.get(d.start_station);
        var  endStationIndex = indexByNameTrip.get(d.end_station);
        if (!od_matrix[startStationIndex]) {
          od_matrix[startStationIndex] = [];
          for (var i = 0; i < n; i++) {
            od_matrix[startStationIndex][i] = 0;
          }
        }
        od_matrix[startStationIndex][endStationIndex]++;;
      });
      return od_matrix;
    }



  </script>


</body>
</html>
