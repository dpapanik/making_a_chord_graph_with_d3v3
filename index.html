<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>Making a Chord Graph</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
  #map_1,#map_2,#map_3 {
    height: 500px;
  }
  </style>

  <!-- D3 v3 -->
  <script src="https://d3js.org/d3.v3.min.js"></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Mobility on Demand Systems: Data-Driven Analysis, Simulation, Visualization</h2>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    </div>
    <div class="two columns">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="twelve columns">
      <h3>Making a Chord Graph</h3>
      <p>
        In this tutorial, you will learn how to make a chord graph.
        This example uses <a href="https://d3js.org/d3.v3.min.js">D3.js v3</a> and <a href="http://getskeleton.com/">Skeleton</a> boilerplate.
        Before you begin, visit and read the following <a href="#links">links</a> at the bottom of this page.
        If you prefer a version that contains only code and not text description, then check out <a href="https://dpapanik.github.io/making_a_chord_graph_with_d3v3/chord_example_step_01.html">part 1</a>, <a href="https://dpapanik.github.io/making_a_chord_graph_with_d3v3/chord_example_step_02.html">part 2</a>, <a href="https://dpapanik.github.io/making_a_chord_graph_with_d3v3/chord_example_step_03.html">part 3</a>, and <a href="https://dpapanik.github.io/making_a_chord_graph_with_d3v3/chord_example_step_04.html">part 4</a> of the code. The GitHub repository for this tutorial is <a href="https://github.com/dpapanik/making_a_chord_graph_with_d3v3">here</a>.
      </p>
    </div>
  </div>


  <div class="container" >
    <div id="chord_01" class="twelve columns">
    </div>
  </div>

  <div class="container half-bottom">
    <div class="twelve columns">
      <h3>Step 1: Setup</h3>
      <p>First, you declare and initiate your control variables, such as number of trips, number of stations, margin and width of the SVG HTML element that will contain the graph, and thickness, diameter, and color for your chord graph's arcs and chords</p>
      <pre>
        <code>
          // STEP 1: Setup
          var nTrips = 30;
          var nStations = 6;

          var margin = 0;
          var width = 600;

          var xPos = margin;
          var yPos = margin;

          var thickness = 30;
          var diameter = width - 2*margin;
          var outerRadius = diameter / 2;
          var innerRadius = outerRadius - thickness;

          var color = d3.scale.linear()
            .domain([0, nStations])
            .range([d3.rgb(255,0,0), d3.rgb(50,0,0)]);
        </code>
      </pre>
    </div>
  </div>

  <div class="container one-bottom">
    <div class="twelve columns">
      <h3>STEP 2: Create/Get Data and OD Matrix</h3>
      <p>Next, you need trip data and station data. You can get real data from anywhere you want. In this tutorial, we create trip and station data synthetically, through functions.
        After you get or create the trip and station data you will need to organize them into an OD (origin-destination) matrix. We thus create a third function <code>createMatrix()</code> to create the OD matrix.</p>
      <pre>
        <code>
          // STEP 2: Create/Get Data and OD Matrix
          var tripData = createTripData(nTrips, nStations);
          var stationData = createStationData(nStations);
          var od_matrix = createMatrix(tripData, stationData);
        </code>
      </pre>

      <p>The function to create trip data takes as input arguments the number of trips <code>nTrips</code> and the number of stations <code>nStations</code>:</p>
      <pre>
        <code>
          function createTripData(nTrips, nStations){
            var trips = [];
            for(var i=0; i< nTrips; i++){
              var origin_index = Math.floor(Math.random() * nStations);
              var destination_index = Math.floor(Math.random() * nStations);
              trips.push({
                start_station: origin_index,
                end_station: destination_index
              })
            }
            return trips;
          }
        </code>
      </pre>

      <p>The function to create station data takes as input arguments the number of stations <code>nStations</code>:</p>
      <pre>
        <code>
          function createStationData(nStations){
            var stations=[];
            for(var i=0; i< nStations; i++){
              stations.push({
                name: i
              })
            }
            return stations;
          }
        </code>
      </pre>

      <p>The function to create an OD matrix from <code>tripData</code> and <code>stationData</code> is:</p>
      <pre>
        <code>
          function createMatrix(tripData, stationData){
            var indexByNameTrip = d3.map();
            var nameByIndexTrip = d3.map();
            var n = 0;
            tripData.forEach(function(d) {
              if (!indexByNameTrip.has(d.start_station)) {
                nameByIndexTrip.set(n, d.start_station);
                indexByNameTrip.set(d.start_station, n++);
              }

            });

            var indexByNameStation = d3.map();
            var nameByIndexStation = d3.map();
            var j = 0;
            stationData.forEach(function(d) {
              if (!indexByNameStation.has(d.name)) {
                nameByIndexStation.set(j, d.name);
                indexByNameStation.set(d.name, j++);
              }
            });


            //Create the OD matrix
            var od_matrix = [];
            tripData.forEach(function(d) {
              var  startStationIndex = indexByNameTrip.get(d.start_station);
              var  endStationIndex = indexByNameTrip.get(d.end_station);
              if (!od_matrix[startStationIndex]) {
                od_matrix[startStationIndex] = [];
                for (var i = 0; i < n; i++) {
                  od_matrix[startStationIndex][i] = 0;
                }
              }
              od_matrix[startStationIndex][endStationIndex]++;;
            });
            return od_matrix;
          }
        </code>
      </pre>
    </div>
  </div>

  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 3: Create Chord Layout</h3>
      <p>
        <code>d3.layout.chord()</code> is a D3 layout object. Read about D3 Layouts <a href="https://d3indepth.com/layouts/">here</a> and about Chord Layout <a href="https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/">here</a>.
        <br>
        Once the Chord Layout is being passed an OD matrix <code>d3.layout.chord().matrix(od_matrix)</code>, it then returns groups and chords arrays as follows:
        <br>
        function <code>d3.layout.chord().groups()</code> returns the groups
        <br>
        function <code>d3.layout.chord().chords()</code> returns the chords
      </p>
      <pre>
        <code>
          // STEP 3: Create Chord Layout
          var chordLayout = d3.layout.chord()
          .matrix(od_matrix)
          .padding(0.05)
          .sortGroups(d3.descending);
        </code>
      </pre>
      <p>Instead of <code>d3.descending</code>, you can also pass custom sorting functions that compare two objects such as <code>function(a,b){...}</code> </p>
    </div>
  </div>


  <div id="step_04" class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 4: Create SVG Shape Generators for arcs and chords</h3>
      <p>
        SVG Shape Generators are special objects in D3 that are used to generate the necessary code for automatically creating SVG elements.
        Since chord graphs consist of arcs and chords, to create a chord graph, we need SVG shape generators to create arcs and chords.
        Read more about SVG Shape Generators <a href="https://d3indepth.com/shapes/">here</a>.
      </p>
      <p>
        <code>d3.svg.arc()</code> is an SVG Shape Generator that is used to create arcs.
        <code>d3.svg.arc()</code> takes a group object as an input and returns its path
        To define an arc SVG Shape Generator you first need to define the inner and outer radii
        function chordLayout.groups() returns an array with all groups (e.g. arc sectors)
        each group object contains a start angle, an end angle, an index number, and a value.
        for example, arc(chordLayout.groups()[2]) returns the path of the third group
      </p>
      <pre>
        <code>
          var arc = d3.svg.arc()
              .innerRadius(innerRadius)
              .outerRadius(outerRadius);
        </code>
      </pre>
      <p>
        Likewise, <code>d3.svg.chord()</code> is an SVG Shape Generator to create chords. It takes a chord object as an input and returns its path.
        To define a chord SVG Shape Generator you first need to define the radious:
      </p>
      <pre>
        <code>
          var chord = d3.svg.chord()
            .radius(innerRadius - 5);
        </code>
      </pre>
      <p>
        <code>chordLayout.chords()</code> returns an array with all chords.
        Each chord object consists of a source and a target, and each of the source and target is a segment of a group with its own start angle and end angle.
        For example, <code>chord(chordLayout.chords()[12])</code> returns the path of the 13th chord.
      </p>
    </div>
  </div>



  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 5: Create the SVG and an empty group "g" to contain the Arc and Chord Shapes that you will be generating</h3>
      <p>
        Create an SVG element in the body of the html page, and define its width and height.
        Then, append an empty "group" (<code>g</code>) inside it, and determine its X,Y origin. The group <code>g</code> is empty because we haven't created anything inside it yet.
        You need this <code>g</code> element in order to start embedding paths inside it and still consider them as one single object (instead of multiple independent paths).
      </p>
      <pre>
        <code>
          var svgGroup = d3.select("#chord_01").append("svg")
            .attr("width", 800)
            .attr("height", 800)
            .append("g")
            .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
        </code>
      </pre>
    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 6: Draw Arcs</h3>
      <p>

      </p>
      <pre>
        <code>
          svgGroup.selectAll(".group")
            .data(chordLayout.groups())
            .enter()
            .append("g")
            .attr("class", "group")
            .append("path")
            .attr("id", function(d, i) { return "group" + i; })
            .style("fill", function(d) { return color(d.index); })
            .style("stroke", d3.rgb(0,0,0))
            .style("stroke-width", 1)
            .attr("d", function(d) { return arc(d)});
        </code>
      </pre>
    </div>
  </div>

  <div class="container" >
    <div id="chord_02" class="twelve columns">
    </div>
  </div>



  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 7: Draw Chords</h3>
      <p>

      </p>
      <pre>
        <code>
          svgGroup.selectAll(".chord")
            .data(chordLayout.chords())
            .enter()
            .append("path")
            .attr("class", "chord")
            .style("fill", d3.rgb(180,180,180))
            .style("stroke", d3.rgb(180,180,180).darker(3))
            .style("opacity", 0.5)
            .attr("d", function(d) { return chord(d)} );
        </code>
      </pre>
    </div>
  </div>



  <div class="container" >
    <div id="chord_03" class="twelve columns">
    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 8: Combine steps 6 and 7 into a single reusable function</h3>
      <p>
        Up till step 7, you learned how to create and draw a chord graph. What if you want your chord graph to interactively change when your data change?
        In this step, we will follow the typical workflow in D3, by creating three functions <code>enter()</code>, <code>update()</code>, <code>exit()</code>.
      </p>
      <p>
        After we bind an array of data to an array of SVG elements (which is done through the <code>.data()</code> function), there are three possible cases:
        (1) the elements of the data array are equal in number to the SVG elements (one-to-one coupling);
        (2) the elements of the data array are more than the SVG elements (more SVG elements are needed for a one-to-one coupling);
        (3) the elements of the data array are fewer than the SVG elements (some SVG elements need to be deleted for a one-to-one coupling);
      </p>
      <p>After the data binding occurs, D3 stores 1) the matched SVG elements, 2) the missing SVG elements, and 3) the excessive unmatched SVG elements, in three different arrays.
        The matched SVG elements are directly accessible by selecting the elements that the data have been previously bound to.
        The missing SVG elements are accessible by the <code>.enter()</code> function. The excessive SVG elements are accessible by the <code>.exit()</code> function.
      </p>





      <h4>Function Update()</h4>
      <p>
        To make our code  more modular, we will create a function that we will call <code>update()</code> that will take as inputs the <code>arc_data</code> and <code>chord_data</code> and within this function we will access each of the three groups of SVG elements sequentially.
      </p>

      <pre>
        <code>
          function update(arc_data, chord_data){

      			// Arcs
      			// Step 1: Bind data to arcs
      			var arcs = svgGroup
      			.selectAll(".arc")
      			.data(arc_data);

      			// Step 2: Append any new arcs if needed
      			arcs
      			.enter()
      			.append("path")
      			.attr("class", "arc");

      			// Step 3: Remove any excessive arcs if needed
      			arcs
      			.exit()
      			.remove();

      			// Step 4: Modify the arcs based on their bound data
      			arcs
      			.attr("id", function(d, i) { return "arc_" + i; })
      			.style("fill", function(d) { return color(d.index); })
      			.style("stroke", d3.rgb(0,0,0))
      			.style("stroke-width", 1)
      			.attr("d", function(d) { return arc(d)});


      			// Chords
      			// STEP 1: Bind data to chords
      			var chords = svgGroup
      			.selectAll(".chord")
      				.data(chord_data);

      			// Step 2: Append any new chords if needed
      			chords
      				.enter()
      				.append("path")
      				.attr("class", "chord");

      			// Step 3: Remove any excessive chords if needed
      			chords
      				.exit()
      				.remove();

      			// Step 4: Modify the chords based on their bound data
      			chords
      				.attr("id", function(d, i) { return "chord_" + i; })
      				.style("fill", d3.rgb(180,180,180))
      				.style("stroke", d3.rgb(180,180,180).darker(3))
      				.style("opacity", 0.5)
      				.attr("d", function(d) { return chord(d)} )

      		}
        </code>
      </pre>

      <p>
        In what follows, I describe each substep of function <code>update()</code> in detail.
      </p>

      <h4>Sub-Step 1: Bind data to elements</h4>
      <p>
        Create a new variable to store each selection, <code>var arcs</code> and <code>var chords</code>.
        Then, from the already saved selection <code>svgGroup</code>, sellect all elements of class <code>.arc</code> (note that if there are no SVG elements of that class yet, the selection will be an empty array with the size of the data array).
        Then, bind the data to the selected SVG elements using the <code>.data()</code> function. After the data binding has happened, the data will be stored in the SVG elements.
      </p>
      <pre>
        <code>
          // Bind data to arcs
          var arcs = svgGroup
            .selectAll(".arc")
            .data(arc_data);

          // Bind data to chords
          var chords = svgGroup
            .selectAll(".chord")
            .data(chord_data);
        </code>
      </pre>

      <h4>Sub-Step 2: Append any new SVG elements if needed</h4>
      <p>
        Select each of the stored selections <code>arcs</code> and <code>chords</code> of SVG elements.
        Then, for each one, get the missing SVG elements by calling the <code>.enter()</code> function. Then, add the missing SVG elements by appending a <code>"path"</code>.
        Finally, change the <code>"class"</code> attribute of each newly added <code>"path"</code> to be <code>"arc"</code> and <code>"chord"</code> respectively.
      </p>
      <pre>
        <code>
          // Sub-Step 2: Append any new arcs if needed
          arcs
            .enter()
            .append("path")
            .attr("class", "arc");

          // Sub-Step 2: Append any new chords if needed
          chords
            .enter()
            .append("path")
            .attr("class", "chord")
        </code>
      </pre>


      <h4>Sub-Step 3: Remove any excessive SVG elements if needed</h4>
      <p>
        After we have added any missing SVG elements, we will now remove any excessive SVG elements. The excessive SVG elements can be accessed by the <code>.exit()</code> function.
        After selecting any excessive SVG elements, remove (delete) them by <code>.remove()</code>:

      </p>
      <pre>
        <code>
          // Sub-Step 3: Remove any excessive arcs if needed
          arcs
            .exit()
            .remove();

          // Sub-Step 3: Remove any excessive chords if needed
          chords
            .exit()
            .remove();
        </code>
      </pre>

      <h4>Sub-Step 4: Modify SVG elements based on their bound data</h4>
      <p>
        After we have added and removed any missing or excessive SVG elements, we will now modify the matched SVG elements based on their bound data.
        There is no special selection function for that - the matched SVG elements are returned by default each time we call the saved selectors <code>arcs</code> or <code>chords</code>.
        First, we change their id attribute, then we change their styling, and finally, we modify appropriately their "d" attribute of their paths, by passing there the SVG Shape Generator functions we created in <a href="#step_04">step 4</a>.
      </p>
      <pre>
        <code>
        // Sub-Step 4: Modify the arcs based on their bound data
        arcs
          .attr("id", function(d, i) { return "arc_" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});

        // Sub-Step 4: Modify the chords based on their bound data
        chords
          .attr("id", function(d, i) { return "chord_" + i; })
          .style("fill", d3.rgb(180,180,180))
          .style("stroke", d3.rgb(180,180,180).darker(3))
          .style("opacity", 0.5)
          .attr("d", function(d) { return chord(d)} )
        </code>
      </pre>



      <h4>Create SVG group</h4>
      <p>We will also need a specialized function to create SVG groups and append them to a given <code>div</code>. This way, we will be able to create SVG group elements anywhere in our page, give them unique IDs, and create multiple chord graphs.</p>
      <pre>
        <code>
          function create_svg_group(div_id, svg_width, svg_height, svg_xPos, svg_yPos){
            var svg_group = d3.select("#"+div_id).append("svg")
              .attr("width", svg_width)
              .attr("height", svg_height)
              .append("g")
              .attr("transform", "translate(" + svg_xPos + "," + svg_yPos + ")");
            return svg_group;
          }
        </code>
      </pre>

    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 9: Combining everything into a single function</h3>
      <p>
        For convenience, we can combine getting/generating data, applying layout to data, and the <code>update()</code> function into one single function that we can call <code>redraw()</code>
      </p>
      <pre>
        <code>
          function redraw(svg_group){
            // Get or Generate data
            var nStations = get_nStations();
            var nTrips = get_nTrips(nStations);

            tripData = createTripData(nTrips, nStations);
            stationData = createStationData(nStations);
            od_matrix = createMatrix(tripData, stationData);

            // Apply layout to data
            chordLayout
              .matrix(od_matrix)
              .sortGroups(d3.descending);

            // Update()
            update(svg_group, chordLayout.groups(), chordLayout.chords());
          }
        </code>
      </pre>
    </div>
  </div>

  <div class="container" >
    <div class="row one-bottom">
      <button class="four columns" onClick="create_svg_group('chord_04', 800, 800, xPos + outerRadius, yPos + outerRadius)">Create SVG</button>
      <button class="four columns" onClick="remove_svg('chord_04')">Remove SVG</button>
      <button class="four columns" onClick="redraw(d3.select('#chord_04').selectAll('svg').select('g'))">Redraw</button>
    </div>

    <div id="chord_04" class="twelve columns">
    </div>
  </div>


  <div class="container one-bottom" >
    <div class="twelve columns">
      <h3>STEP 10: Adding labels and ticks</h3>
      <p>
        Below is the full code for the <code>update()</code> function including the addition of the ticks. Ticks are presented as percentages. The sum of all arcs constitutes 100%.
        Each arc starts from 0% and ends at the percentage that the outgoing trips from that arc occupy from the total volume of trips.
      </p>
      <pre>
        <code>
          function update(svg_group, arc_data, chord_data){

            // Arcs
            // Step 1: Bind data to arcs
            var arcs = svg_group
            .selectAll(".arc")
            .data(arc_data);

            // Step 2: Append any new arcs if needed
            arcs
            .enter()
            .append("path")
            .attr("class", "arc");

            // Step 3: Remove any excessive arcs if needed
            arcs
            .exit()
            .remove();

            // Step 4: Modify the arcs based on their bound data
            arcs
            .attr("id", function(d, i) { return "arc_" + i; })
            .style("fill", function(d) { return color(d.index); })
            .style("stroke", d3.rgb(0,0,0))
            .style("stroke-width", 1)
            .attr("d", function(d) { return arc(d)});


            // Chords
            // STEP 1: Bind data to chords
            var chords = svg_group
            .selectAll(".chord")
            .data(chord_data);

            // Step 2: Append any new chords if needed
            chords
            .enter()
            .append("path")
            .attr("class", "chord");

            // Step 3: Remove any excessive chorsa if needed
            chords
            .exit()
            .remove();

            // Step 4: Modify the chords based on their bound data
            chords
            .attr("id", function(d, i) { return "chord_" + i; })
            .style("fill", d3.rgb(180,180,180))
            .style("stroke", d3.rgb(180,180,180).darker(3))
            .style("opacity", 0.5)
            .attr("d", function(d) { return chord(d)} )


            //TickGroups
            // Step 1: Bind data to tick groups
            var tickGroups = svg_group
            .selectAll(".tickGroups")
            .data(arc_data);

            // Step 2: Append any new tick groups if needed
            tickGroups
            .enter()
            .append("g")
            .attr("class", "tickGroups");

            // Step 3: Remove any excessive tick groups if needed
            tickGroups
            .exit()
            .remove();


            //Ticks
            // Step 1: Bind data
            var ticks = tickGroups
            .selectAll("g")
            .data(groupTicks);

            // Step 2: Append any new elements if needed
            // SubStep 2.1: Append any new ticks if needed
            var tick = ticks
            .enter()
            .append("g");

            // SubStep 2.2: Within each tick append any new lines if needed
            tick
            .append("line")
            .attr("x1", 1)
            .attr("y1", 0)
            .attr("x2", 10)
            .attr("y2", 0)
            .style("stroke", "#000");

            // SubStep 2.3: Within each tick append any new text if needed
            tick
            .append("text")
            .attr("x", 15)
            .attr("font-size", "11px")
            .attr("dy", ".35em");


            // Step 3: Remove any excessive elements if needed
            ticks
            .exit()
            .remove();


            // Step 4: Modify elements based on their bound data
            ticks
            .attr("transform", function(d) {
              return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
              + "translate(" + (outerRadius + 10) + ",0)";
            });

            ticks
            .selectAll("text")
            .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-30)" : null; })
            .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
            .text(function(d) { return d.label; });

          }
        </code>
      </pre>
    </div>
  </div>

  <div class="container" >
    <div class="twelve columns one-bottom">
      <h3>STEP 11: Try it</h3>
      <p>Click the "CREATE SVG" button below to create an SVG placeholder and then the "REDRAW" button to create a Chord graph with ticks</p>
    </div>
    <div class="row one-bottom">
      <button class="four columns" onClick="create_svg_group('chord_05', 800, 800, xPos + outerRadius, yPos + outerRadius)">Create SVG</button>
      <button class="four columns" onClick="remove_svg('chord_05')">Remove SVG</button>
      <button class="four columns" onClick="redraw_v2(d3.select('#chord_05').selectAll('svg').select('g'))">Redraw</button>
    </div>

    <div id="chord_05" class="twelve columns">
    </div>
  </div>




  <div id="links" class="container one-bottom" >
    <div class="twelve columns">
      <h2>Links</h2>
      <h4>D3.JS</h4>
      <ul>
        <li><a href="https://www.dashingd3js.com/">Dashing D3js</a></li>
        <li><a href="https://www.d3indepth.com/">D3 In Depth</a></li>
        <li><a href="http://square.github.io/intro-to-d3/">Intro to D3js by Square</a></li>
      </ul>
      <h4>D3 Layouts</h4>
      <ul>
        <li>  <a href="https://d3indepth.com/layouts/">D3 In Depth Layouts</a></li>
        <li> <a href="https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/">Chord Layout</a> </li>
        <li> Read answer <a href="https://stackoverflow.com/questions/21813723/change-and-transition-dataset-in-chord-diagram-with-d3">"Creating a Chord Diagram"</a>  by <a href="https://stackoverflow.com/users/3128209/ameliabr">AmeliaBR</a> in Stack Overflow (scroll down until you find the answer) </li>
      </ul>

    </div>
  </div>


  <div class="container one-bottom" style="margin-top: 50px">
    <div class="four columns offset-by-four">
      <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>


  <script type="text/javascript">

    // Chord Graph Tutorial by Dimitris Papanikolaou
    // 2019 02 3


    // STEP 1: Setup
    var nTrips = 30;
    var nStations = 6;

    var margin = 50;
    var width = 600;

    var xPos = margin;
    var yPos = margin;

    var thickness = 30;
    var diameter = width - 2*margin;
    var outerRadius = diameter / 2;
    var innerRadius = outerRadius - thickness;

    var color = d3.scale.linear()
      .domain([0, nStations])
      .range([d3.rgb(255,0,0), d3.rgb(50,0,0)]);


    // STEP 2: Create/Get Data and OD Matrix
    var tripData = createTripData(nTrips, nStations);
    var stationData = createStationData(nStations);
    var od_matrix = createMatrix(tripData, stationData);



    // STEP 3: Create Chord Layout
    var chordLayout = d3.layout.chord()
      .matrix(od_matrix)
      .padding(0.05)
      .sortGroups(d3.descending); // You can also pass custom sorting functions that compare two objects like function(a,b){...}
    // About d3.layout.chord():
    // d3.layout.chord() is a D3 layout object. Read about D3 Layouts here: https://d3indepth.com/layouts/ and about Chord Layout here: https://d3-wiki.readthedocs.io/zh_CN/master/Chord-Layout/
    // Once the Chord Layout is being assigned an OD matrix ( d3.layout.chord().matrix(od_matrix) ), it can return groups and chords arrays as follows:
    // function chordLayout.groups() returns the groups
    // function chordLayout.chords() returns the chords


    // STEP 4: Create SVG Shape Generators for arcs and chords
    var arc = d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);
    // About d3.svg.arc():
    // d3.svg.arc() is an SVG Shape Generator. Read more about SVG Shape Generators here: https://d3indepth.com/shapes/
    // d3.svg.arc() takes a group object as an input and returns its path
    // To define an arc SVG Shape Generator you first need to define the inner and outer radii
    // function chordLayout.groups() returns an array with all groups (e.g. arc sectors)
    // each group object contains a start angle, an end angle, an index number, and a value.
    // for example, arc(chordLayout.groups()[2]) returns the path of the third group


    var chord = d3.svg.chord()
      .radius(innerRadius - 5);
    // About d3.svg.chord():
    // d3.svg.chord() is also an SVG Shape Generator. It takes a chord object as an input and returns its path
    // To define a chord SVG Shape Generator you first need to define the radious
    // chordLayout.chords() returns an array with all chords
    // each chord object consists of a source and a target, and each of the source and target is a segment of a group with its own start angle and end angle
    // for example, chord(chordLayout.chords()[12]) returns the path of the 13th chord


    // STEP 5: Create the SVG and an empty group "g" to contain the Arc and Chord Shapes that you will be generating
    var svgGroup = d3.select("#chord_01").append("svg")
      .attr("width", 800)
      .attr("height", 800)
      .append("g")
      .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
    // Create an SVG element in the body of the html page, and define its width and height
    // Then, append an empty "group" (g) inside it, and determine its X,Y origin
    // You need this g element in order to start embedding paths inside it and consider them as a single object.



    // STEP 6: Draw Arcs/Groups
    svgGroup.selectAll(".group")
      .data(chordLayout.groups())
      .enter()
      .append("g")
      .attr("class", "group")
      .append("path")
      .attr("id", function(d, i) { return "group" + i; })
      .style("fill", function(d) { return color(d.index); })
      .style("stroke", d3.rgb(0,0,0))
      .style("stroke-width", 1)
      .attr("d", function(d) { return arc(d)})
      .on("hover", function (d,i) {
      })
      .on("click", function (d,i) {
      });

    // STEP 7: Draw Chords
    svgGroup.selectAll(".chord")
      .data(chordLayout.chords())
      .enter()
      .append("path")
      .attr("class", "chord")
      .style("fill", d3.rgb(180,180,180))
      .style("stroke", d3.rgb(180,180,180).darker(3))
      .style("opacity", 0.5)
      // .style("opacity", function(d){
      // 	if(d.source.index==2 || d.target.index==2)
      // 		return 1;
      // 	else
      // 		return 0.1
      // })
      .attr("d", function(d) { return chord(d)} )
      .on("hover", function (d) {
      })
      .on("click", function (d,i) {
      });




      var svg2 = d3.select("#chord_02").append("svg")
        .attr("width", 800)
        .attr("height", 800)
        .append("g")
        .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
      svg2.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});


      var svg3 = d3.select("#chord_03").append("svg")
        .attr("width", 800)
        .attr("height", 800)
        .append("g")
        .attr("transform", "translate(" + (xPos + outerRadius) + "," + (yPos + outerRadius) + ")");
      svg3.selectAll(".group")
          .data(chordLayout.groups())
          .enter()
          .append("g")
          .attr("class", "group")
          .append("path")
          .attr("id", function(d, i) { return "group" + i; })
          .style("fill", function(d) { return color(d.index); })
          .style("stroke", d3.rgb(0,0,0))
          .style("stroke-width", 1)
          .attr("d", function(d) { return arc(d)});
      svg3.selectAll(".chord")
        .data(chordLayout.chords())
        .enter()
        .append("path")
        .attr("class", "chord")
        .style("fill", d3.rgb(180,180,180))
        .style("stroke", d3.rgb(180,180,180).darker(3))
        .style("opacity", 0.5)
        .attr("d", function(d) { return chord(d)} );



    /********************/
    /********************/
    /***** FUNCTIONS ****/
    /********************/
    /********************/


    function get_nStations() {
      return 4 + Math.round(Math.random()*10);
    }
    function get_nTrips(nStations) {
      return nStations*10;
    }

    function createTripData(nTrips, nStations){
      var trips = [];
      for(var i=0; i<nTrips; i++){
        var origin_index = Math.floor(Math.random() * nStations);
        var destination_index = Math.floor(Math.random() * nStations);
        trips.push({
          start_station: origin_index,
          end_station: destination_index
        })
      }
      return trips;
    }
    function createStationData(nStations){
      var stations=[];
      for(var i=0; i<nStations; i++){
        stations.push({
          name: i
        })
      }
      return stations;
    }

    function createMatrix(tripData, stationData){
      var indexByNameTrip = d3.map();
      var nameByIndexTrip = d3.map();
      var n = 0;
      tripData.forEach(function(d) {
        if (!indexByNameTrip.has(d.start_station)) {
          nameByIndexTrip.set(n, d.start_station);
          indexByNameTrip.set(d.start_station, n++);
        }

      });

      var indexByNameStation = d3.map();
      var nameByIndexStation = d3.map();
      var j = 0;
      stationData.forEach(function(d) {
        if (!indexByNameStation.has(d.name)) {
          nameByIndexStation.set(j, d.name);
          indexByNameStation.set(d.name, j++);
        }
      });


      //Create the OD matrix
      var od_matrix = [];
      tripData.forEach(function(d) {
        var  startStationIndex = indexByNameTrip.get(d.start_station);
        var  endStationIndex = indexByNameTrip.get(d.end_station);
        if (!od_matrix[startStationIndex]) {
          od_matrix[startStationIndex] = [];
          for (var i = 0; i < n; i++) {
            od_matrix[startStationIndex][i] = 0;
          }
        }
        od_matrix[startStationIndex][endStationIndex]++;;
      });
      return od_matrix;
    }

    function create_svg_group(div_id, svg_width, svg_height, svg_xPos, svg_yPos){
      var svg_group = d3.select("#"+div_id).append("svg")
        .attr("width", svg_width)
        .attr("height", svg_height)
        .append("g")
        .attr("transform", "translate(" + svg_xPos + "," + svg_yPos + ")");
      return svg_group;
    }

    function remove_svg(div_id){
      d3.select("#"+div_id).selectAll("svg").remove();
    }

    function redraw(svg_group){
      // Get or Generate data
      var nStations = get_nStations();
      var nTrips = get_nTrips(nStations);

      var tripData = createTripData(nTrips, nStations);
      var stationData = createStationData(nStations);
      var od_matrix = createMatrix(tripData, stationData);

      // Apply layout to data
      chordLayout
        .matrix(od_matrix)
        .sortGroups(d3.descending);

      // Update()
      update(svg_group, chordLayout.groups(), chordLayout.chords())
    }


    function update(svg_group, arc_data, chord_data){
      // Arcs
      // Step 1: Bind data to arcs
      var arcs = svg_group
      .selectAll(".arc")
      .data(arc_data);

      // Step 2: Append any new arcs if needed
      arcs
      .enter()
      .append("path")
      .attr("class", "arc");

      // Step 3: Remove any excessive arcs if needed
      arcs
      .exit()
      .remove();

      // Step 4: Modify the arcs based on their bound data
      arcs
      .attr("id", function(d, i) { return "arc_" + i; })
      .style("fill", function(d) { return color(d.index); })
      .style("stroke", d3.rgb(0,0,0))
      .style("stroke-width", 1)
      .attr("d", function(d) { return arc(d)});


      // Chords
      // STEP 1: Bind data to chords
      var chords = svg_group
      .selectAll(".chord")
      .data(chord_data);

      // Step 2: Append any new chords if needed
      chords
      .enter()
      .append("path")
      .attr("class", "chord");

      // Step 3: Remove any excessive chorsa if needed
      chords
      .exit()
      .remove();

      // Step 4: Modify the chords based on their bound data
      chords
      .attr("id", function(d, i) { return "chord_" + i; })
      .style("fill", d3.rgb(180,180,180))
      .style("stroke", d3.rgb(180,180,180).darker(3))
      .style("opacity", 0.5)
      .attr("d", function(d) { return chord(d)} )

    }


    function update_v2(svg_group, arc_data, chord_data){

      // Arcs
      // Step 1: Bind data to arcs
      var arcs = svg_group
      .selectAll(".arc")
      .data(arc_data);

      // Step 2: Append any new arcs if needed
      arcs
      .enter()
      .append("path")
      .attr("class", "arc");

      // Step 3: Remove any excessive arcs if needed
      arcs
      .exit()
      .remove();

      // Step 4: Modify the arcs based on their bound data
      arcs
      .attr("id", function(d, i) { return "arc_" + i; })
      .style("fill", function(d) { return color(d.index); })
      .style("stroke", d3.rgb(0,0,0))
      .style("stroke-width", 1)
      .attr("d", function(d) { return arc(d)});


      // Chords
      // STEP 1: Bind data to chords
      var chords = svg_group
      .selectAll(".chord")
      .data(chord_data);

      // Step 2: Append any new chords if needed
      chords
      .enter()
      .append("path")
      .attr("class", "chord");

      // Step 3: Remove any excessive chorsa if needed
      chords
      .exit()
      .remove();

      // Step 4: Modify the chords based on their bound data
      chords
      .attr("id", function(d, i) { return "chord_" + i; })
      .style("fill", d3.rgb(180,180,180))
      .style("stroke", d3.rgb(180,180,180).darker(3))
      .style("opacity", 0.5)
      .attr("d", function(d) { return chord(d)} )


      //TickGroups
      // Step 1: Bind data to tick groups
      var tickGroups = svg_group
      .selectAll(".tickGroups")
      .data(arc_data);

      // Step 2: Append any new tick groups if needed
      tickGroups
      .enter()
      .append("g")
      .attr("class", "tickGroups");

      // Step 3: Remove any excessive tick groups if needed
      tickGroups
      .exit()
      .remove();


      //Ticks
      // Step 1: Bind data
      var ticks = tickGroups
      .selectAll("g")
      .data(groupTicks);

      // Step 2: Append any new elements if needed
      // SubStep 2.1: Append any new ticks if needed
      var tick = ticks
      .enter()
      .append("g");

      // SubStep 2.2: Within each tick append any new lines if needed
      tick
      .append("line")
      .attr("x1", 1)
      .attr("y1", 0)
      .attr("x2", 10)
      .attr("y2", 0)
      .style("stroke", "#000");

      // SubStep 2.3: Within each tick append any new text if needed
      tick
      .append("text")
      .attr("x", 15)
      .attr("font-size", "11px")
      .attr("dy", ".35em");


      // Step 3: Remove any excessive elements if needed
      ticks
      .exit()
      .remove();


      // Step 4: Modify elements based on their bound data
      ticks
      .attr("transform", function(d) {
        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
        + "translate(" + (outerRadius + 10) + ",0)";
      });

      ticks
      .selectAll("text")
      .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-30)" : null; })
      .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
      .text(function(d) { return d.label; });

    }


    function redraw_v2(svg_group){
      // Get or Generate data
      var nStations = get_nStations();
      var nTrips = get_nTrips(nStations);

      var tripData = createTripData(nTrips, nStations);
      var stationData = createStationData(nStations);
      var od_matrix = createMatrix(tripData, stationData);

      // Apply layout to data
      chordLayout
        .matrix(od_matrix)
        .sortGroups(d3.descending);


      // Update()
      update_v2(svg_group, chordLayout.groups(), chordLayout.chords());
    }

    // Returns an array of tick angles and labels, given a group.
		function groupTicks(d,i) {
			var k = (d.endAngle - d.startAngle) / (d.value);
			return d3.range(0, d.value,1).map(function(v, i) {
				return {
					angle: v * k + d.startAngle,
					label: i % 5 ? null : v  + "%"
				};
			});
		}

  </script>


</body>
</html>
